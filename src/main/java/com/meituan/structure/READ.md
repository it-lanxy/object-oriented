####结构型模式
    Adapter   Pattern：适配器模式
    Bridge    Pattern：桥接模式
    Composite Pattern：组合模式
    Decorator Pattern：装饰模式
    Facade    Pattern：外观模式
    Flyweight Pattern：享元模式
    Proxy     Pattern：代理模式
    
####结构型模式如何应对"变化的"：
    
   
    适配器：面向对象的精神是更好的应对需求的变化，而现实中往往会有下面这些情况，想使用一个已经存在的类，而它的接口不符合要求，或者希望创建一个
        可以复用的类，该类可以与其他不相关的类或不可预见的类协同工作。
    桥接：解耦的方式，用聚合来代替继承。，继承是个好东西，但往往会过度的使用，继承会导致类的结构过于复杂，关系太多，难以维护，而更糟糕的是扩展性非常差。
        而仔细研究，如果能发现继承体系中，有两个甚至多个方向的变化，那么就解耦这些不同方向的变化，通过对象组合的方式，把两个角色之间的继承关系
        改为了组合的关系，从而使者两者可以应对各自独立的变化，事实上也是 合成聚合复用所提倡的原则。
    装饰：面对变化，如果采用生成子类的方式进行扩充，为支持每一种扩展的组合，会产生大量的子类，使得子类数目呈爆炸性增长。这也是之前桥接所提到的
        继承所带来的灾难，而事实上，这些子类多半只是为某个对象增加一些职责，此时通过装饰的方式，可以更加灵活，以动态、透明的方式给单个对象添加
        职责，并在不需要时，撤销相应的职责。
    组合：擅长表示部分与整体的层次结构，用户可以忽略组合对象和单个对象的不同，用户将可以统一地使用组合结构中的所有对象，任何用到基本对象
        的地方都可以使用组合对象。
    外观：信息的隐藏促进了软件的复用。类之间的耦合越弱，越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及。如果两个类不必彼此直接
        通信，那么就不要让这两个类发生作用。如果实在需要调用，可以引入一个外观对象，为子系统提供一个单一而简单的屏障。
    代理：代理与外观的区别在于，代理对象代表一个单一对象而外观对象代表一个子系统；代理的客户对象无法直接访问目标对象，由代理提供对单独的目标
        对象的访问控制，而外观的控制对象可以直接访问子系统中各个对象，但通常由外观对象提供对子系统各元件功能的简化的共同层次的调用接口。
        代理与适配器都属于衔接性质的功能，代理是一种原来对象的代表，其他需要与这个对象打交道的操作都是和这个代表交涉。而适配器则不需要虚构出
        一个代表着，只需要为应付特定使用目的，将原来的类进行一些组合。